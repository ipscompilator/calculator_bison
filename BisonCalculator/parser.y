/* prologue */

%defines

// Skeleton implementation for Bison LALR(1) parsers in C++
%skeleton "lalr1.cc"
%define parser_class_name {Parser}

/* verbose error messages */
%error-verbose

%{
    #pragma warning(disable:4996)
    #include <iostream>
    #include <cmath>

    // this function is generated by flex
    extern int yylex();

    extern void yyerror(char const* msg);

    extern double calcResult;

%}



%union
{
    double dbl;
};

%token<dbl>    LITERAL_DBL

%type<dbl>    sum_expr
%type<dbl>    mul_expr
%type<dbl>    unary_expr
%type<dbl>    symbol

%start program


%%

/* rules section */

program: /* empty */
    | program sum_expr '\n'   { std::cout << $2 << std::endl; calcResult = $2; }
    ;

sum_expr: mul_expr            { $$ = $1; }
    | sum_expr '+' mul_expr   { $$ = $1 + $3; }
    | sum_expr '-' mul_expr   { $$ = $1 - $3; }
    ;

mul_expr: unary_expr             { $$ = $1; }
    | mul_expr '*' unary_expr    { $$ = $1 * $3; }
    | mul_expr '/' unary_expr    { $$ = $1 / $3; }
    ;

unary_expr: symbol    { $$ = $1; }
    | '+' symbol      { $$ = $2; }
    | '-' symbol      { $$ = -$2; }
    ;

symbol: LITERAL_DBL        { $$ = $1; }
    | '(' sum_expr ')'     { $$ = $2; }
    ;

%%

/* epilogue */

void yyerror(char const* msg) 
{
    std::cout << "Syntax error: " << msg << std::endl;
}
